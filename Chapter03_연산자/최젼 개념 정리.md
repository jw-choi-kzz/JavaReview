연산자
===
  
연산자 종류 : 산술, 비교, 논리, 대입 (+) 그 외: **(type)** 형변환 연산자, 조건 **?** 참일때수행 **:** 거짓일때수행(삼항 연산자), **instanceof** 연산자  
  
연산자 우선순위 : 산술 > 비교 > 논리 > 대입. 단항 > 이항 > 삼항.  
단항연산자(++ -- + - ~ ! (type)), 산술(* / %, + -, << >>), 비교(< > <= >= instanceof, == !=), 논리(& ^ | && ||), 삼항(? : ), 대입(= += <<= >>= &=...)    
**단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 from왼to오**  
  
**산술 변환** : 연산 수행 전에 자동으로 두 피연산자의 타입을 **보다 큰 타입으로** 일치 시킨다. 만약 피연산자의 타입이 int보다 작다면 **int**로 변환.  
  
------------
  
단항 연산자
===
  
++증감 연산자(전위형: 값 참조 전에 처리), 후위형++(값 참조 후에 처리). (독립적으로 쓰인거면 별 차이 없음)  
  
------
  
산술 연산자
===

int형 / int형에서 나머지는 버려진다  
java에서 /0(나누기 0)은 오류를 발생시킨다
(ex) byte a = 10, b = 20; 에서 byte c = a+b를 하면 산술변환(**만약 피연산자의 타입이 int보다 작다면 *int*로 변환**)으로 인해 *컴파일 에러* 발생.  
byte형에 넣어주기 위해 **다시 명시적 형변환** (byte)(a+b) 해줘야 함.  
  
문자는 실제로 해당 문자의 유니코드로 바뀌어 저장되기 때문에, 문자 간 사칙연산은 정수간의 연산과 동일.  
문자를 숫자로 변환하려면 그 수에 -'0' (문자 '0'을 빼줘야 함) : '2'-'0'을 하면 **'2'의 유니코드 50** 빼기 **'0'의 유니코드 48**의 결과 2가 나옴.  
  
Math.round() : 소수점 첫째자리에서 반올림해주는 메서드  

나머지 연산자 %는 주로 홀짝, 배수검사 등에 사용  
  
------
  
비교 연산자
===
  
'0' != 0 ('0' == 48이기 때문), 'A' == 65('A' ==65),  'A'+1 == 'B'('A'+1 == 65+1 == 66 =='B')   
  
문자열의 비교는 == 대신 **.equals()** 메서드 사용. (대소문자 구별 안하고 비교하고 싶다면 **equalsIgnoreCase()** 사용)  
  
----------
  
논리 연산자
===
    
(ex) i는 2의 배수 또는 3의 배수지만, 6의 배수는 아니다 : (i%2==0 || i%3==0) && i%6!=0   
(ex) 문자 ch는 숫자 ('0'에서 '9' 사이) : '0' <= ch && ch <= '9'   
(ex) 문자 ch는 대문자 또는 소문자이다 : ('a'<= ch && ch <= 'z') || ('A'<=ch && ch <='Z')  
  
|| 연산의 경우 결과가 **참**일 확률이 높은 피연산자를 **왼쪽부분**에 놓으면 더 빠른 연산 결과 얻을 수 있음(앞에서 참이면 뒤의 조건은 확인 안하고 참)  
  
### 비트연산자  
피연산자를 이진수로 표현했을 때의 각 자리를 연산.  
|(한 쪽 값이 1이면 1), &(모두 1이여야 1), ^(서로 다를 때면 1)  
  
비트 전환 연산자 ~ : 0은 1로, 1은 0으로 = **1의 보수 연산자**   
  
**쉬프트 연산자** : 피연산자의 각 자리를 오른쪽 또는 왼쪽으로 이동함  
ex. 8 << 2 = 8의 2인수를 왼쪽으로 2자리 이동. 저장 범위를 벗어난 값들은 버려지고, 빈자리는 0으로 채워짐. 00001000 이었던 것이 2자리씩 이동해서 00100000 이 됨.  
오른쪽 쉬프트 연산자에서 음수를 이동시킬 때는, 부호를 유지하기 위해 빈자리를 1로 채움  
(( [Start_230829] 수업시간에 swea '이진수 표현'문제 풀 때, for( i from 0 to n-1 ) {if ((m&(1<<i))==0) { ans="OFF"; break;}} 이런식으로 1<<i 와 m의 이진수 표현을 비교하여 모두 1이 아닌 경우(m&(1<<i))==0)가 있는지 판단함))  
  
+) x<< n은 x*2의 n승 의 결과와 같다. x>>n은 x/2의 n승의 결과와 같다  
  
-----------
   
그 외(조건 연산자, 대입연산자)
--
  
조건식 ? (참) 식1: (거짓) 식2  
(ex) result = ( x > y ) ? x : y ; (if 조건 result 값 설정, else result값 설정 하는 식보다 코드 간단해짐)  
   
lvalue = rvalue  에서 lvalue는 반드시 변수처럼 값을 변경할 수 있는 것.   
복합 대입 연산자 : += -= *= /= %= <<= >>= &= ^= |=  
(ex) i *= 10 + j  는 i = i * (10+j) 와 같음  
