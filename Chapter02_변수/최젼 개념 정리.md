변수(variable)
==
  
  
**변수** : 단 하나의 값을 저장할 수 있는 메모리 공간  
  
타입이 같은 경우에는  int a, b; 또는 int a = 0, b = 0; 같이 한 줄에 여러 변수 선언 가능  
  
  
변수의 명명 규칙
---
  
**<식별자 명명규칙>**  
1. 대소문자가 구분되며 길이에 제한이 없다.  
2. 예약어(키워드, 리져브드reserved 워드)를 사용해서는 안된다.  
3. 숫자로 시작해서는 안 된다.  
4. 특수문자는 _와 $만 허용한다.  
      
+) 암묵적 규칙  
1. 클래스 이름의 첫 글자는 항상 대문자로 한다. (변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다)  
2. 여러 변수로 이루어진 이름은 단어의 첫 글자를 대문자로 한다. (ex) StringBuffer  
3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 _로 구분한다. (ex) MAX_VALUE  
  
----  
  
변수의 타입
====
  
**기본형** : 논리형boolean, 문자형char, 정수형(byte short int long), 실수형(float double) 계산을 위한 실제 값data을 저장(8개)  
**참조형** : 객체의 주소memory address 저장.기본형 8개 제외한 나머지들  
  
  
참조형변수를 사용할때는 변수 타입을 클래스이름으로 사용  
사실상 선언시  
```
클래스명(=변수타입) 변수명

Date today = new Date();  
```  
new 객체 Date를 생성하고 그 주소를 today에 저장하겠다  
  
  
기본형(primitive type)
----
  
문자형 char = 하나의 문자만 저장(내부적으로 정수.유니코드로 저장. 정수형, 실수형과 연산 가능)  
  
정수형  
byte = 이진 데이터 다룰 때  
short = C언어와의 호환  
int = 주로 사용되는 정수형. 가장 효율적으로 처리할 수 있는 타입(문제에서 주어지는 정수 범위가 -2의 31승 ~ **2의 31승-1** 정도라면 int 사용)  
long  
  
### 리터럴    
  
사실 이해 못함..p.32~35   


### printf()  
System.out.printf("들어갈 내용이랑 중간에 지시자", 지시자 안에 들어갈 것들);  
줄바꿈은 %n  
자주 쓰는 지시자 : %b (boolean) , **%d(10진 정수)** , %o(8진 정수) , %x(16진 정수) , **%f(부동 소수점 float)** , %e(지수 표현식) , **%c(char)** , **%s(String)**    
   
```
//ex)

int binNum = 0b10; //2진수 10, 10진수로는 2
System.out.printf("binNum= %s, %d%n",Integer.toBinaryString(binNum) , binNum);
//여기서" "안에 "binNum= "까지 그대로, "%s"은 " " 뒤에 나온 Integer.toBinaryString(binNum) 가 들어가고, "%d"는 " " 뒤에 나온 binNum, "%n" 은 줄바꿈 표시
//출력은 binNum= 10, 2
```
  
----  
  
진법
====

**정수를 n진수로** : 수를 n으로 나누고 나머지값을 아래서부터 순서대로 적으면 완성  
(2진수) 10 = (10진수) 2   
(2진수) 1010 = (10진수) 10   
10진수에서 9보다 큰 수를 표현하기 위해서는 두 자리의 10진수가 필요하다 = 2진수에서 2를 표현하기 위해서는 두 자리의 2진수가 필요하다  
**2진수를 8진수로** : 2진수를 뒤에서부터 **3자리**씩 끊어서 해당하는 8진수로 바꾸면 됨,  **16진수로 변환** : 2진수를 뒤에서부터 **4자리**씩 끊어서 해당하는 16진수로 바꾸면 됨  
  
**n진수를 10진수로** : 각 자리의 수에 해당 단위의 값을 곱해서 모두 더함  
  
실수의 진법 변환(pass)  
  
#### 음수의 2진 표현 : 2의 보수법  
어떤 수의 n의 보수 : 더했을 때 n이 되는 수 (ex. 7의 10의 보수는 3).  
음수를 표현하려면 **왼쪽의 첫번째 비트**가(MSB) 0이면 양수, **1이면 음수**.  
보수 관계에 있는 두 수를 더하면 자리올림 발생 후 0이 됨 (ex. **0**101(5)와 **1**011(-5)를 더하면 10000(자리올림 발생 후 **1**0000. 하지만 4비트라서 맨 앞의 1은 버려짐 = 0000)  

#### 음수를 2진수로 표현하기  
10의 음의정수 > 절대값을 2진수로 변환 > 그 수의 2의 보수 구함
ex. -5 > 5의 2진수 = 0101 > 2의 보수 1011  
  
서로 보수관계에 있는 두 수를 더하면 자리올림이 발생.  
**2의 보수는 1의 보수+1**  
: 0101의 1의 보수는 1010(0->1 1->0으로). 둘을 더하면 1111. 여기에 1을 더하면 (1)0000 = 이건 위에서 2의 보수를 더했을 때 의 결과와 똑같음  
**2의 보수나, 1의 보수+1이나 결과는 같다 = 음수의 2진 표현은, 음수의 절대값을 2진수로 바꾸고, 이것의 1의 보수를 구한다음, +1을 한다**  
   
-------------

기본형
===
  
boolean의 기본값은 false  

char에는 유니코드가 저장됨(ex. A = 65)   
(+) '0'~'9'까지의 문자에도 유니코드가 있음(80~89). 형변환 제대로 해주고 써야함  
  
int형이 표현 가능한 정수의 범위는 약 +-20억. 이 범위를 벗어날 때는 long을 사용해주면 됨.  
**오버플로우** : 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것. 오버플로우의 결과는 최대값+1이 최소값, 최소값-1은 최대값이 되어 이 범위를 계속 반복한다고 보면 됨.  
부호 있는 정수는 부호비트가 0에서 1이 될 때 오버플로우 발생.  
  
실수형에서 오버플로우가 발생하면 변수의 값이 무한대가 됨  
실수형에는 실수형으로 표현할 수 없는 아주 작은 값(양의 최소값보다 작은 값)이 되는 경우 = **언더플로우**가 발생. 이때 변수의 값은 0  
실수형 변수 중 float보다 **double**을 많이 사용하는 이유는 **높은 정밀도** 때문.  
실수형의 저장 형식은 부동소수점 형태: 부호+- & 가수(실제 값 저장) & 지수로 구성 
  
-----
  
형 변환
===
  
변수 또는 상수의 타입을 다른 타입으로 변환하는 것  
(타입)피연산자.  
ex. (char)65 = 'A', (int)'A'=65, (int)1.6f = (반올림 아닌 **버림** 처리해서) 1, (float)10 = 10.0f  
큰 타입에서 작은 것으로 변환 시 값 손실 발생 가능.  

#### 자동 형변환 
: 기존 값을 최대한 보존할 수 있는 타입으로.    
(값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략 가능  








